"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

// These files are auto-generated by 'npm run genabi'
import { DietTrackerABI } from "@/abi/DietTrackerABI";
import { DietTrackerAddresses } from "@/abi/DietTrackerAddresses";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

/**
 * Convert a 32-bit encrypted integer to a signed int using a robust heuristic.
 * Supports both encodings:
 * - Two's complement: value >= 2^31 -> value - 2^32
 * - Centered at 2^31: decoded = value - 2^31
 * Returns the candidate with the smallest absolute magnitude.
 */
function convertToSigned32(value: string | bigint | boolean): string | bigint | boolean {
  if (typeof value === "boolean") {
    return value;
  }

  const MAX_INT32 = 2147483647n;   // 2^31 - 1
  const MOD_32 = 2n ** 32n;        // 2^32
  const PIVOT = 2n ** 31n;         // 2^31

  let bigIntValue: bigint;

  if (typeof value === "bigint") {
    bigIntValue = value;
  } else if (typeof value === "string") {
    try {
      bigIntValue = BigInt(value);
    } catch {
      return value; // Not numeric string
    }
  } else {
    return value;
  }

  const tc = bigIntValue > MAX_INT32 ? bigIntValue - MOD_32 : bigIntValue; // two's complement
  const centered = bigIntValue - PIVOT;                                     // centered at 2^31

  const abs = (x: bigint) => (x < 0n ? -x : x);
  return abs(tc) <= abs(centered) ? tc : centered;
}

type DietTrackerInfoType = {
  abi: typeof DietTrackerABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

function getDietTrackerByChainId(chainId: number | undefined): DietTrackerInfoType {
  if (!chainId) {
    return { abi: DietTrackerABI.abi };
  }

  const entry = DietTrackerAddresses[chainId.toString() as keyof typeof DietTrackerAddresses];

  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: DietTrackerABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: DietTrackerABI.abi,
  };
}

export const useDietTracker = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  // States
  const [latestRecord, setLatestRecord] = useState<{
    caloriesInHandle?: string;
    caloriesOutHandle?: string;
    balanceHandle?: string;
    timestamp?: bigint;
  } | undefined>(undefined);
  
  const [clearValues, setClearValues] = useState<{
    caloriesIn?: ClearValueType;
    caloriesOut?: ClearValueType;
    balance?: ClearValueType;
  } | undefined>(undefined);
  
  const [avgBalanceHandle, setAvgBalanceHandle] = useState<string | undefined>(undefined);
  const [clearAvgBalance, setClearAvgBalance] = useState<ClearValueType | undefined>(undefined);
  
  const [recordCount, setRecordCount] = useState<bigint | undefined>(undefined);
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isCalculatingAvg, setIsCalculatingAvg] = useState<boolean>(false);
  const [isDecryptingAvg, setIsDecryptingAvg] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const dietTrackerRef = useRef<DietTrackerInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isSubmittingRef = useRef<boolean>(isSubmitting);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const isCalculatingAvgRef = useRef<boolean>(isCalculatingAvg);
  const isDecryptingAvgRef = useRef<boolean>(isDecryptingAvg);
  const clearValuesRef = useRef<typeof clearValues>(undefined);
  const clearAvgBalanceRef = useRef<ClearValueType | undefined>(undefined);

  // DietTracker contract info
  const dietTracker = useMemo(() => {
    const c = getDietTrackerByChainId(chainId);
    dietTrackerRef.current = c;
    // Only show deployment not found message when:
    // 1. chainId is defined (not undefined)
    // 2. The chainId exists in DietTrackerAddresses but has zero address, or doesn't exist in DietTrackerAddresses
    if (chainId !== undefined) {
      const entry = DietTrackerAddresses[chainId.toString() as keyof typeof DietTrackerAddresses];
      // If entry exists but address is zero, or entry doesn't exist, show message
      if ((entry && entry.address === ethers.ZeroAddress) || !entry) {
        setMessage(`Contract not available on this network (Chain ID: ${chainId})`);
      } else if (entry && entry.address !== ethers.ZeroAddress) {
        // Clear message if we have a valid address
        setMessage("");
      }
    } else {
      // If chainId is undefined, clear deployment-related messages to prevent false alerts
      // Only clear if the current message is about deployment not found
      setMessage((prev) => {
        if (prev.includes("Contract not available")) {
          return "";
        }
        return prev;
      });
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!dietTracker) {
      return undefined;
    }
    return Boolean(dietTracker.address && dietTracker.address !== ethers.ZeroAddress);
  }, [dietTracker]);

  // Get record count
  const refreshRecordCount = useCallback(() => {
    if (isRefreshingRef.current) return;

    if (!dietTrackerRef.current?.address || !ethersReadonlyProvider) {
      setRecordCount(undefined);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = dietTrackerRef.current.chainId;
    const thisAddress = dietTrackerRef.current.address;

    const contract = new ethers.Contract(
      thisAddress!,
      dietTrackerRef.current.abi,
      ethersReadonlyProvider
    );

    contract
      .getRecordCount()
      .then((count: bigint) => {
        if (sameChain.current(thisChainId) && thisAddress === dietTrackerRef.current?.address) {
          setRecordCount(count);
        }
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e: Error) => {
        setMessage("Failed to fetch record count: " + e.message);
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, sameChain]);

  // Get latest record
  const refreshLatestRecord = useCallback(() => {
    if (isRefreshingRef.current) return;

    if (!dietTrackerRef.current?.address || !ethersReadonlyProvider) {
      setLatestRecord(undefined);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = dietTrackerRef.current.chainId;
    const thisAddress = dietTrackerRef.current.address;

    const contract = new ethers.Contract(
      thisAddress!,
      dietTrackerRef.current.abi,
      ethersReadonlyProvider
    );

    contract
      .getLatestRecord()
      .then((result: [string, string, string, bigint]) => {
        if (sameChain.current(thisChainId) && thisAddress === dietTrackerRef.current?.address) {
          setLatestRecord({
            caloriesInHandle: result[0],
            caloriesOutHandle: result[1],
            balanceHandle: result[2],
            timestamp: result[3],
          });
        }
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e: Error) => {
        setMessage("Failed to fetch latest record: " + e.message);
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, sameChain]);

  // Auto refresh
  useEffect(() => {
    refreshRecordCount();
    refreshLatestRecord();
  }, [refreshRecordCount, refreshLatestRecord]);

  // Submit daily data
  const canSubmit = useMemo(() => {
    return (
      dietTracker.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isSubmitting
    );
  }, [dietTracker.address, instance, ethersSigner, isRefreshing, isSubmitting]);

  const submitDailyData = useCallback(
    (caloriesIn: number, caloriesOut: number) => {
      if (isRefreshingRef.current || isSubmittingRef.current) return;

      if (!dietTracker.address || !instance || !ethersSigner) return;

      const thisChainId = chainId;
      const thisAddress = dietTracker.address;
      const thisEthersSigner = ethersSigner;

      isSubmittingRef.current = true;
      setIsSubmitting(true);
      setMessage("Encrypting your data...");

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisAddress !== dietTrackerRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          // Create encrypted input
          const input = instance.createEncryptedInput(
            thisAddress,
            thisEthersSigner.address
          );
          input.add32(BigInt(caloriesIn));
          input.add32(BigInt(caloriesOut));

          const enc = await input.encrypt();

          if (isStale()) {
            setMessage("Action cancelled");
            return;
          }

          setMessage("Submitting to blockchain...");

          const contract = new ethers.Contract(
            thisAddress,
            dietTracker.abi,
            thisEthersSigner
          );

          const tx = await contract.submitDailyData(
            enc.handles[0],
            enc.handles[1],
            enc.inputProof
          );

          setMessage(`Transaction pending...`);

          const receipt = await tx.wait();

          setMessage(`Successfully recorded your daily data!`);

          if (isStale()) return;

          refreshRecordCount();
          refreshLatestRecord();
        } catch (error) {
          setMessage(`Failed to submit data: ${(error as Error).message}`);
        } finally {
          isSubmittingRef.current = false;
          setIsSubmitting(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      dietTracker.address,
      dietTracker.abi,
      instance,
      chainId,
      refreshRecordCount,
      refreshLatestRecord,
      sameChain,
      sameSigner,
    ]
  );

  // Decrypt latest record
  const canDecrypt = useMemo(() => {
    return (
      dietTracker.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      latestRecord?.balanceHandle &&
      latestRecord.balanceHandle !== ethers.ZeroHash
    );
  }, [
    dietTracker.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
    latestRecord,
  ]);

  const decryptLatestRecord = useCallback(() => {
    if (isRefreshingRef.current || isDecryptingRef.current) return;

    if (!dietTracker.address || !instance || !ethersSigner || !latestRecord) return;

    // Check if already decrypted
    if (
      latestRecord.balanceHandle === clearValuesRef.current?.balance?.handle &&
      latestRecord.caloriesInHandle === clearValuesRef.current?.caloriesIn?.handle &&
      latestRecord.caloriesOutHandle === clearValuesRef.current?.caloriesOut?.handle
    ) {
      return;
    }

    if (!latestRecord.balanceHandle || latestRecord.balanceHandle === ethers.ZeroHash) {
      setClearValues(undefined);
      clearValuesRef.current = undefined;
      return;
    }

    const thisChainId = chainId;
    const thisAddress = dietTracker.address;
    const thisLatestRecord = latestRecord;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Preparing to decrypt...");

    const run = async () => {
      const isStale = () =>
        thisAddress !== dietTrackerRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig = await FhevmDecryptionSignature.loadOrSign(
          instance,
          [dietTracker.address as `0x${string}`],
          ethersSigner,
          fhevmDecryptionSignatureStorage
        );

        if (!sig) {
          setMessage("Unable to create decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Action cancelled");
          return;
        }

        setMessage("Decrypting your data...");

        // Decrypt all three handles
        const handles = [
          { handle: thisLatestRecord.caloriesInHandle!, contractAddress: thisAddress },
          { handle: thisLatestRecord.caloriesOutHandle!, contractAddress: thisAddress },
          { handle: thisLatestRecord.balanceHandle!, contractAddress: thisAddress },
        ];

        const res = await instance.userDecrypt(
          handles,
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("Successfully decrypted!");

        if (isStale()) {
          setMessage("Action cancelled");
          return;
        }

        // Convert all decrypted values to signed 32-bit integers if needed
        const newClearValues = {
          caloriesIn: {
            handle: thisLatestRecord.caloriesInHandle!,
            clear: convertToSigned32(res[thisLatestRecord.caloriesInHandle!]),
          },
          caloriesOut: {
            handle: thisLatestRecord.caloriesOutHandle!,
            clear: convertToSigned32(res[thisLatestRecord.caloriesOutHandle!]),
          },
          balance: {
            handle: thisLatestRecord.balanceHandle!,
            clear: convertToSigned32(res[thisLatestRecord.balanceHandle!]),
          },
        };

        setClearValues(newClearValues);
        clearValuesRef.current = newClearValues;

        setMessage(
          `Your data: Consumed ${newClearValues.caloriesIn.clear}, Burned ${newClearValues.caloriesOut.clear}, Balance ${newClearValues.balance.clear}`
        );
      } catch (error) {
        console.error("Decryption failed:", error);
        setMessage("Failed to decrypt data");
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    dietTracker.address,
    instance,
    latestRecord,
    chainId,
    sameChain,
    sameSigner,
  ]);

  // Calculate average balance
  const canCalculateAvg = useMemo(() => {
    return (
      dietTracker.address &&
      ethersSigner &&
      !isRefreshing &&
      !isCalculatingAvg &&
      recordCount &&
      recordCount > 0n
    );
  }, [dietTracker.address, ethersSigner, isRefreshing, isCalculatingAvg, recordCount]);

  const calculateAverageBalance = useCallback(
    (numRecords: number) => {
      if (isRefreshingRef.current || isCalculatingAvgRef.current) return;

      if (!dietTracker.address || !ethersSigner || !recordCount || recordCount === 0n) return;

      const thisChainId = chainId;
      const thisAddress = dietTracker.address;
      const thisEthersSigner = ethersSigner;

      isCalculatingAvgRef.current = true;
      setIsCalculatingAvg(true);
      setMessage("Computing average balance...");

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisAddress !== dietTrackerRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const contract = new ethers.Contract(
            thisAddress,
            dietTracker.abi,
            thisEthersSigner
          );

          setMessage("Processing calculation...");

          // For functions that return values, we can use staticCall to get the return value
          // before sending the transaction, or we can decode it from the transaction result
          // Since this function returns a value, let's use staticCall to simulate and get the result
          const result = await contract.calculateAverageBalance.staticCall(numRecords);

          if (isStale()) {
            setMessage("Action cancelled");
            return;
          }

          // Now send the actual transaction
          setMessage("Submitting to blockchain...");
          const tx = await contract.calculateAverageBalance(numRecords);

          setMessage(`Transaction pending...`);

          const receipt = await tx.wait();

          if (isStale()) {
            setMessage("Action cancelled");
            return;
          }

          setAvgBalanceHandle(result);
          setMessage(`Average calculated successfully!`);
        } catch (e: any) {
          if (isStale()) {
            setMessage("Action cancelled");
            return;
          }
          setMessage("Failed to calculate average: " + e.message);
        } finally {
          isCalculatingAvgRef.current = false;
          setIsCalculatingAvg(false);
        }
      };

      run();
    },
    [dietTracker.address, dietTracker.abi, ethersSigner, chainId, recordCount, sameChain, sameSigner]
  );

  // Decrypt average balance
  const canDecryptAvg = useMemo(() => {
    return (
      dietTracker.address &&
      instance &&
      ethersSigner &&
      !isDecryptingAvg &&
      avgBalanceHandle &&
      avgBalanceHandle !== ethers.ZeroHash
    );
  }, [dietTracker.address, instance, ethersSigner, isDecryptingAvg, avgBalanceHandle]);

  const decryptAverageBalance = useCallback(() => {
    if (isDecryptingAvgRef.current) return;

    if (!dietTracker.address || !instance || !ethersSigner || !avgBalanceHandle) return;

    if (avgBalanceHandle === ethers.ZeroHash) {
      setClearAvgBalance({ handle: avgBalanceHandle, clear: BigInt(0) });
      clearAvgBalanceRef.current = { handle: avgBalanceHandle, clear: BigInt(0) };
      return;
    }

    const thisChainId = chainId;
    const thisAddress = dietTracker.address;
    const thisAvgBalanceHandle = avgBalanceHandle;
    const thisEthersSigner = ethersSigner;

    isDecryptingAvgRef.current = true;
    setIsDecryptingAvg(true);
    setMessage("Preparing to decrypt average...");

    const run = async () => {
      const isStale = () =>
        thisAddress !== dietTrackerRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig = await FhevmDecryptionSignature.loadOrSign(
          instance,
          [dietTracker.address as `0x${string}`],
          ethersSigner,
          fhevmDecryptionSignatureStorage
        );

        if (!sig) {
          setMessage("Unable to create decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Action cancelled");
          return;
        }

        setMessage("Decrypting average balance...");

        const res = await instance.userDecrypt(
          [{ handle: thisAvgBalanceHandle, contractAddress: thisAddress }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("Successfully decrypted!");

        if (isStale()) {
          setMessage("Action cancelled");
          return;
        }

        // Convert the decrypted value to signed 32-bit integer if needed
        // Be robust: if the handle key doesn't map (e.g., due to simulation handle mismatch),
        // fall back to the first value in the result map.
        let rawValue: string | bigint | boolean | undefined = res[thisAvgBalanceHandle];
        if (rawValue === undefined) {
          const values = Object.values(
            res as Record<string, string | bigint | boolean>
          );
          rawValue = values.length > 0 ? values[0] : 0n;
        }
        const convertedValue = convertToSigned32(rawValue as string | bigint | boolean);
        
        const newClearAvg = {
          handle: thisAvgBalanceHandle,
          clear: convertedValue,
        };

        setClearAvgBalance(newClearAvg);
        clearAvgBalanceRef.current = newClearAvg;

        setMessage(`Your average balance is ${newClearAvg.clear} calories per day`);
      } catch (error) {
        console.error("Decryption failed:", error);
        setMessage("Failed to decrypt average");
      } finally {
        isDecryptingAvgRef.current = false;
        setIsDecryptingAvg(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    dietTracker.address,
    instance,
    avgBalanceHandle,
    chainId,
    sameChain,
    sameSigner,
  ]);

  return {
    contractAddress: dietTracker.address,
    isDeployed,
    canSubmit,
    canDecrypt,
    canCalculateAvg,
    canDecryptAvg,
    submitDailyData,
    decryptLatestRecord,
    calculateAverageBalance,
    decryptAverageBalance,
    refreshRecordCount,
    refreshLatestRecord,
    message,
    recordCount,
    latestRecord,
    clearValues,
    avgBalanceHandle,
    clearAvgBalance,
    isRefreshing,
    isSubmitting,
    isDecrypting,
    isCalculatingAvg,
    isDecryptingAvg,
  };
};

